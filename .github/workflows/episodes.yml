name: Check for new podcast episodes

on:
  workflow_dispatch:

jobs:
  check-episodes:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Get latest release info for cache key
        id: release_info
        run: |
          # Get just the release info to determine cache key
          RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.PAT }}" \
                          "https://api.github.com/repos/${{ secrets.CHECKER }}/releases/latest")
          
          # Extract tag name for cache key
          RELEASE_TAG=$(echo "$RESPONSE" | jq -r '.tag_name')
          echo "Latest release: $RELEASE_TAG"
          echo "tag_name=$RELEASE_TAG" >> $GITHUB_OUTPUT

      - name: Cache checker binary
        id: cache-checker
        uses: actions/cache@v4
        with:
          path: |
            ./checker
          key: checker-binary-${{ steps.release_info.outputs.tag_name }}
          restore-keys: |
            checker-binary-

      - name: Download checker binary
        if: steps.cache-checker.outputs.cache-hit != 'true'
        run: |
          # Get the latest release info
          echo "Fetching latest release info from: https://api.github.com/repos/${{ secrets.CHECKER }}/releases/latest"
          
          # Use a temporary file to store the response and status separately
          RESPONSE_FILE=$(mktemp)
          HTTP_STATUS=$(curl -s -w "%{http_code}" -H "Authorization: token ${{ secrets.PAT }}" 
                             -o "$RESPONSE_FILE" 
                             "https://api.github.com/repos/${{ secrets.CHECKER }}/releases/latest")
          
          echo "HTTP Status: $HTTP_STATUS"
          
          # Check HTTP status
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "Error: API request failed with status $HTTP_STATUS"
            if [ "$HTTP_STATUS" = "404" ]; then
              echo "Repository not found or no releases exist. Please check:"
              echo "1. Repository name in secrets.CHECKER: ${{ secrets.CHECKER }}"
              echo "2. PAT token has access to the repository"
              echo "3. Repository has at least one published release"
            elif [ "$HTTP_STATUS" = "401" ]; then
              echo "Authentication failed. Please check the PAT token permissions."
            fi
            echo "Response:"
            cat "$RESPONSE_FILE"
            rm -f "$RESPONSE_FILE"
            exit 1
          fi
          
          echo "Release info received successfully. Parsing assets..."
          
          # Debug: Show first few lines of the response file
          echo "Response file content (first 10 lines):"
          head -n 10 "$RESPONSE_FILE"
          echo "---"
          
          # Debug: Check if it's valid JSON
          if ! jq empty "$RESPONSE_FILE" 2>/dev/null; then
            echo "Error: Response file contains invalid JSON"
            echo "Full content:"
            cat "$RESPONSE_FILE"
            rm -f "$RESPONSE_FILE"
            exit 1
          fi
          
          # Check if assets exist and extract the download URL
          ASSETS_COUNT=$(jq -r '.assets | length' "$RESPONSE_FILE")
          if [ "$ASSETS_COUNT" = "0" ] || [ "$ASSETS_COUNT" = "null" ]; then
            echo "Error: No assets found in the latest release"
            RELEASE_TAG=$(jq -r '.tag_name' "$RESPONSE_FILE")
            echo "Release tag: $RELEASE_TAG"
            rm -f "$RESPONSE_FILE"
            exit 1
          fi
          
          echo "Found $ASSETS_COUNT assets in the release"
          
          # Extract the download URL for the linux-amd64 tar.gz file
          # First, let's debug what assets we have
          echo "Available assets:"
          jq -r '.assets[].name' "$RESPONSE_FILE"
          echo "---"
          
          # Use a simpler approach: get all assets and filter in bash
          DOWNLOAD_URL=""
          API_URL=""
          while IFS= read -r asset_name; do
            if [[ "$asset_name" == *"linux-amd64.tar.gz"* && "$asset_name" != *".md5"* ]]; then
              API_URL=$(jq -r --arg name "$asset_name" '.assets[] | select(.name == $name) | .url' "$RESPONSE_FILE")
              DOWNLOAD_URL=$(jq -r --arg name "$asset_name" '.assets[] | select(.name == $name) | .browser_download_url' "$RESPONSE_FILE")
              break
            fi
          done < <(jq -r '.assets[].name' "$RESPONSE_FILE")
          
          if [ -z "$DOWNLOAD_URL" ] || [ "$DOWNLOAD_URL" = "null" ]; then
            echo "Error: No linux-amd64.tar.gz asset found in the release"
            echo "Looked for assets containing 'linux-amd64.tar.gz' but not '.md5'"
            rm -f "$RESPONSE_FILE"
            exit 1
          fi
          
          echo "Downloading binary from API URL (private repo): $API_URL"
          
          # Clean up the response file
          rm -f "$RESPONSE_FILE"
          
          # Download the binary using API URL for private repositories
          curl -L -H "Authorization: token ${{ secrets.PAT }}" \
               -H "Accept: application/octet-stream" \
               -o checker.tar.gz \
               "$API_URL"
          
          # Verify the download
          if [ ! -f checker.tar.gz ]; then
            echo "Error: Failed to download the binary"
            exit 1
          fi
          
          # Check file size (should be much larger than a few bytes)
          FILE_SIZE=$(stat -c%s "checker.tar.gz" 2>/dev/null || stat -f%z "checker.tar.gz" 2>/dev/null || echo "0")
          echo "Downloaded file size: $FILE_SIZE bytes"
          
          if [ "$FILE_SIZE" -lt 1000 ]; then
            echo "Error: Downloaded file is too small ($FILE_SIZE bytes), likely an error response"
            echo "File content:"
            cat checker.tar.gz
            exit 1
          fi
          
          echo "Binary downloaded successfully"
          tar -xzf checker.tar.gz
          rm -f checker.tar.gz  # Clean up tar file after extraction
          chmod +x checker
          echo "Binary extracted and ready to use"

      - name: Prepare cached binary
        if: steps.cache-checker.outputs.cache-hit == 'true'
        run: |
          echo "Using cached checker binary"
          chmod +x checker
          echo "Cached binary ready to use"

      - name: Run checker
        run: |
          ./checker rss --data ${GITHUB_WORKSPACE}/data

      - name: Clean up binary before commit
        run: rm -f checker.tar.gz

      - name: Add & Commit
        id: add_commit
        uses: EndBug/add-and-commit@v9.1.4
        with:
          message: "Added new episodes"
          add: "./data"
          push: true
          new_branch: new-episodes

      - name: Create pull request
        uses: devops-infra/action-pull-request@v1.0.2
        if: steps.add_commit.outputs.committed == 'true'
        with:
          github_token: ${{ secrets.PUSH }}
          body: "**Automated pull request after adding new episodes**"
          title: "Added new episodes"
          source_branch: new-episodes
          target_branch: main
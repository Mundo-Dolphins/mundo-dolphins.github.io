name: ðŸš€ Notify new Bluesky posts to Telegram

on:
  push:
    branches: [ main ]
    paths:
      - 'data/posts_*.json'
      - '.github/workflows/notify-social-posts.yml'

concurrency:
  group: notify-social-posts
  cancel-in-progress: false

jobs:
  notify-social-posts:
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ”„ Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 2

      - name: ðŸ“¥ Restore cache (last sent post date)
        uses: actions/cache/restore@v4
        with:
          path: .github/notifications/last_post_date.txt
          key: social-posts-last-date
          restore-keys: |
            social-posts-last-date

      - name: ðŸ“¤ Detect and send posts to Telegram
        id: notify
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
            echo "Missing TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID environment variables"
            exit 1
          fi
          
          LAST_NOTIFIED_DATE="${{ steps.last_notified.outputs.last_notified_date }}"
          echo "Filtering posts published after: $LAST_NOTIFIED_DATE"
          
          # Convert last notified date to timestamp for comparison
          if [ -n "$LAST_NOTIFIED_DATE" ]; then
            LAST_TIMESTAMP=$(date -d "$LAST_NOTIFIED_DATE" +%s 2>/dev/null || echo "0")
          else
            LAST_TIMESTAMP=0
          fi
          echo "Last cached timestamp: $LAST_TIMESTAMP"
          
          # If no cached date or cache is invalid, query Telegram for the last message date
          if [ $LAST_TIMESTAMP -eq 0 ]; then
            echo "âš ï¸ No cached date found. Querying Telegram for last message..."
            
            # Get the last message from the Telegram channel
            telegram_response=$(curl -s "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/getUpdates?chat_id=$TELEGRAM_CHAT_ID&limit=1&offset=-1")
            
            # Try to get date from last message
            last_msg_date=$(echo "$telegram_response" | jq -r '.result[-1].message.date // empty' 2>/dev/null)
            
            if [ -n "$last_msg_date" ] && [ "$last_msg_date" != "null" ]; then
              LAST_TIMESTAMP=$last_msg_date
              echo "âœ… Found last Telegram message at timestamp: $LAST_TIMESTAMP ($(date -u -d @$LAST_TIMESTAMP +%Y-%m-%dT%H:%M:%SZ))"
            else
              # Alternative: get channel history directly
              echo "Trying alternative method: getting chat history..."
              history_response=$(curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/getChat" \
                -d chat_id="$TELEGRAM_CHAT_ID")
              
              # If still no date, use 24 hours ago as ultimate fallback
              if [ $LAST_TIMESTAMP -eq 0 ]; then
                TWENTY_FOUR_HOURS_AGO=$(date -u -d '24 hours ago' +%s)
                LAST_TIMESTAMP=$TWENTY_FOUR_HOURS_AGO
                echo "âš ï¸ Could not retrieve Telegram message date. Using 24-hour fallback: $(date -u -d @$LAST_TIMESTAMP +%Y-%m-%dT%H:%M:%SZ)"
              fi
            fi
          fi
          
          echo "Effective timestamp filter: $LAST_TIMESTAMP ($(date -u -d @$LAST_TIMESTAMP +%Y-%m-%dT%H:%M:%SZ))"
          
          # Create a temporary file to store all posts to process
          temp_posts_file=$(mktemp)
          
          for file in $(cat changed_posts_files.txt); do
            echo "Processing $file..."
            jq -c '.[] | select(.stype == 0) | select(.PublishedOn != null and .BlueSkyPost.Description != null and .BlueSkyPost.BskyPost != null)' "$file" >> "$temp_posts_file"
          done
          
          # Sort and deduplicate all posts by post URL (BlueSkyPost.BskyPost) before processing
          if [ -s "$temp_posts_file" ]; then
            echo "Found posts to process. Deduplicating and sorting by publication date..."
            dedup_posts_file=$(mktemp)
            # unique_by requires reading as array; we keep only posts with a non-empty BskyPost
            jq -s '[.[] | select(.BlueSkyPost.BskyPost != null and .BlueSkyPost.BskyPost != "") ] | unique_by(.BlueSkyPost.BskyPost) | sort_by(.PublishedOn)' "$temp_posts_file" > "$dedup_posts_file"

            # if dedup result is empty, no posts to process
            if [ ! -s "$dedup_posts_file" ]; then
              echo "No valid posts after deduplication"
              echo "latest_notified_date=" >> $GITHUB_OUTPUT
              echo "posts_sent=0" >> $GITHUB_OUTPUT
              rm -f "$dedup_posts_file"
              rm -f "$temp_posts_file"
              exit 0
            fi

            sorted_posts_file="$dedup_posts_file"

            total_posts=$(jq length "$sorted_posts_file")
            echo "Total posts to evaluate: $total_posts"
            
            latest_notified_date=""
            posts_sent=0
            
            # Process each post
            for i in $(seq 0 $((total_posts - 1))); do
              post=$(jq -r ".[$i]" "$sorted_posts_file")
              published=$(echo "$post" | jq -r '.PublishedOn // empty')
              text=$(echo "$post" | jq -r '.BlueSkyPost.Description // empty')
              url=$(echo "$post" | jq -r '.BlueSkyPost.BskyPost // empty')
              
              # Convert post date to timestamp for comparison
              if [ -n "$published" ]; then
                post_timestamp=$(date -d "$published" +%s 2>/dev/null || echo "0")
              else
                post_timestamp=0
              fi
              
              # Only publish if timestamp is greater than last notified timestamp
              if [ "$post_timestamp" -gt "$LAST_TIMESTAMP" ]; then
                echo "Processing post $((i+1))/$total_posts published at: $published"
                if [ -n "$text" ] && [ -n "$url" ]; then
                  # Escape special characters for Telegram Markdown V2
                  # Replace problematic characters that break Markdown
                  escaped_text=$(echo "$text" | sed 's/\\/\\\\/g' | sed 's/_/\\_/g' | sed 's/\*/\\*/g' | sed 's/\[/\\[/g' | sed 's/]/\\]/g' | sed 's/(/\\(/g' | sed 's/)/\\)/g' | sed 's/~/\\~/g' | sed 's/`/\\`/g' | sed 's/>/\\>/g' | sed 's/#/\\#/g' | sed 's/+/\\+/g' | sed 's/-/\\-/g' | sed 's/=/\\=/g' | sed 's/|/\\|/g' | sed 's/{/\\{/g' | sed 's/}/\\}/g' | sed 's/\./\\./g' | sed 's/!/\\!/g')
                  
                  # Create message with proper formatting
                  message="${escaped_text}%0A%0AðŸ”— ${url}"
                  echo "Sending post to Telegram: $url"
                  
                  retry_count=0
                  max_retries=3
                  
                  while [ $retry_count -lt $max_retries ]; do
                    response=$(curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
                      -d chat_id="$TELEGRAM_CHAT_ID" \
                      -d text="$message" \
                      -d parse_mode="MarkdownV2" \
                      -d disable_web_page_preview=false)
                    
                    ok=$(echo "$response" | jq -r '.ok')
                    
                    if [ "$ok" = "true" ]; then
                      echo "âœ… Successfully sent post $((i+1))/$total_posts: $url"
                      latest_notified_date="$published"
                      posts_sent=$((posts_sent + 1))
                      break
                    fi
                    
                    error_code=$(echo "$response" | jq -r '.error_code // empty')
                    error_desc=$(echo "$response" | jq -r '.description // empty')
                    
                    if [ "$error_code" = "429" ]; then
                      retry_after=$(echo "$response" | jq -r '.parameters.retry_after // 30')
                      echo "â³ Rate limit hit (429). Waiting $retry_after seconds..."
                      sleep $retry_after
                      retry_count=$((retry_count + 1))
                    elif [ "$error_code" = "400" ] && [[ "$error_desc" == *"parse entities"* ]]; then
                      echo "âš ï¸ Markdown parsing error. Retrying without formatting..."
                      # Retry without Markdown formatting
                      simple_message="${text}%0A%0AðŸ”— ${url}"
                      response=$(curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
                        -d chat_id="$TELEGRAM_CHAT_ID" \
                        -d text="$simple_message")
                      ok=$(echo "$response" | jq -r '.ok')
                      if [ "$ok" = "true" ]; then
                        echo "âœ… Successfully sent post (plain text) $((i+1))/$total_posts: $url"
                        latest_notified_date="$published"
                        posts_sent=$((posts_sent + 1))
                      else
                        echo "âŒ Failed to send even without formatting: $url"
                        echo "Response: $response"
                      fi
                      break
                    else
                      echo "âŒ Telegram error sending post $((i+1))/$total_posts: $url"
                      echo "Error: $error_desc"
                      break
                    fi
                  done
                  
                  # Small delay between messages
                  sleep 1
                else
                  echo "âš ï¸ Skipping post $((i+1))/$total_posts due to missing text or URL"
                fi
              else
                echo "â­ï¸ Skipping post $((i+1))/$total_posts - already processed (published: $published, timestamp: $post_timestamp vs $LAST_TIMESTAMP)"
              fi
            done
            
            # Save the latest notified date to outputs for caching
            if [ -n "$latest_notified_date" ]; then
              echo "Latest notified post date: $latest_notified_date"
              echo "$latest_notified_date" > last_notified_post_date.txt
              echo "latest_notified_date=$latest_notified_date" >> $GITHUB_OUTPUT
              echo "posts_sent=$posts_sent" >> $GITHUB_OUTPUT
            else
              echo "No new posts were sent"
              echo "latest_notified_date=" >> $GITHUB_OUTPUT
              echo "posts_sent=0" >> $GITHUB_OUTPUT
            fi
            
            rm -f "$sorted_posts_file"
          else
            echo "No posts found to process"
            echo "latest_notified_date=" >> $GITHUB_OUTPUT
            echo "posts_sent=0" >> $GITHUB_OUTPUT
          fi
          
          rm -f "$temp_posts_file"

      - name: Save last notified post date cache
        if: steps.detect_posts.outputs.has_new_posts == 'true' && steps.send_posts.outputs.posts_sent > 0
        uses: actions/cache/save@v4
        continue-on-error: true
        with:
          path: .github/notifications/last_post_date.txt
          key: social-posts-last-date

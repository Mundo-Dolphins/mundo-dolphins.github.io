# ---
# This workflow sends notifications to Telegram when a new article or podcast is published.
# Automatically detects new articles or podcasts when pushed to the main branch.
# Example message sent:
# üéôÔ∏è Nuevo cap√≠tulo del podcast publicado: Dolphins Podcast Ep. 1
# üîó https://mundodolphins.es/podcast/episodio-1/
# Requires TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID secrets configured in the repository.
# ---

name: üöÄ Notify new articles or podcasts to Telegram

on:
  push:
    branches: [ main ]
    paths:
      - 'content/noticias/**/*.md'
      - 'data/season_**.json'

jobs:
  detect-and-notify:
    runs-on: ubuntu-latest
    env:
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
    steps:
      - name: üîÑ Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 2
          
      - name: üîç Detect new articles and podcasts
        id: detect_content
        run: |
          echo "üîç Checking for new articles..."
          NEW_ARTICLES=$(git diff --name-only HEAD~1 HEAD | grep -E '^content/noticias/.*\.md$' || true)
          NEW_PODCASTS=$(git diff --name-only HEAD~1 HEAD | grep -E '^data/season_.*\.json$' || true)
          
          # Initialize content arrays
          ALL_CONTENT="[]"
          
          # Process articles
          if [ -n "$NEW_ARTICLES" ]; then
            echo "üÜï New articles detected:"
            echo "$NEW_ARTICLES"
            
            # Install yq for parsing YAML frontmatter
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq
            
            for file in $NEW_ARTICLES; do
              if [ -f "$file" ]; then
                echo "üìù Processing article: $file"
                TITLE=$(yq '.title' "$file" 2>/dev/null | sed 's/^null$//' || echo "New Article")
                AUTHOR=$(yq '.author' "$file" 2>/dev/null | sed 's/^null$//' || echo "Mundo Dolphins")
                FILENAME=$(basename "$file" .md)
                SECTION="noticias"
                URL="https://mundodolphins.es/${SECTION}/${FILENAME}/"
                
                ARTICLE_JSON=$(jq -n \
                  --arg title "$TITLE" \
                  --arg url "$URL" \
                  --arg author "$AUTHOR" \
                  --arg section "$SECTION" \
                  '{title: $title, url: $url, author: $author, section: $section}')
                ALL_CONTENT=$(echo "$ALL_CONTENT" | jq ". + [$ARTICLE_JSON]")
                echo "‚úÖ Article processed: $TITLE"
                echo "üîó URL: $URL"
              fi
            done
          else
            echo "‚ÑπÔ∏è No new articles detected"
          fi
          
          # Process podcasts
          if [ -n "$NEW_PODCASTS" ]; then
            echo "üÜï New podcasts detected:"
            echo "$NEW_PODCASTS"
            
            for file in $NEW_PODCASTS; do
              echo "üîç Detecting new podcast episodes in $file..."
              if [ -f "$file" ]; then
                # First, validate JSON
                if ! jq empty "$file" 2>/dev/null; then
                  echo "‚ö†Ô∏è File $file is not valid JSON, skipping."
                  continue
                fi
                
                # Get array length to process episodes safely
                EPISODES_COUNT=$(jq length "$file")
                echo "üìä Found $EPISODES_COUNT episodes in $file"
                
                # Process each episode by index instead of using pipeline
                for i in $(seq 0 $((EPISODES_COUNT - 1))); do
                  EPISODE=$(jq -r ".[$i]" "$file")
                  if [ "$EPISODE" != "null" ]; then
                    TITLE=$(echo "$EPISODE" | jq -r '.title // "Nuevo Podcast"')
                    # Create slug from title since there's no slug field
                    FILENAME=$(echo "$TITLE" | sed 's/[^a-zA-Z0-9 ]//g' | sed 's/ /-/g' | tr '[:upper:]' '[:lower:]')
                    URL="https://mundodolphins.es/podcast/${FILENAME}/"
                    
                    PODCAST_JSON=$(jq -n \
                      --arg title "$TITLE" \
                      --arg url "$URL" \
                      --arg section "podcast" \
                      '{title: $title, url: $url, section: $section}')
                    ALL_CONTENT=$(echo "$ALL_CONTENT" | jq ". + [$PODCAST_JSON]")
                    echo "‚úÖ Podcast processed: $TITLE"
                    echo "üîó URL: $URL"
                  fi
                done
              fi
            done
          else
            echo "‚ÑπÔ∏è No new podcasts detected"
          fi
          
          # Save content count for next step
          CONTENT_COUNT=$(echo "$ALL_CONTENT" | jq length)
          echo "has_content=$([ "$CONTENT_COUNT" -gt 0 ] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "content_count=$CONTENT_COUNT" >> $GITHUB_OUTPUT
          echo "$ALL_CONTENT" > all_content.json
          echo "üìä Total content items to notify: $CONTENT_COUNT"

      - name: üì± Send notifications to Telegram
        if: steps.detect_content.outputs.has_content == 'true'
        run: |
          if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
            echo "‚ùå Missing TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID environment variables"
            exit 1
          fi
          
          ALL_CONTENT=$(cat all_content.json)
          CONTENT_COUNT="${{ steps.detect_content.outputs.content_count }}"
          
          echo "üì± Sending $CONTENT_COUNT notifications to Telegram..."
          
          for i in $(seq 0 $((CONTENT_COUNT - 1))); do
            ITEM=$(echo "$ALL_CONTENT" | jq -r ".[$i]")
            TITLE=$(echo "$ITEM" | jq -r '.title')
            URL=$(echo "$ITEM" | jq -r '.url')
            SECTION=$(echo "$ITEM" | jq -r '.section')
            
            if [ "$SECTION" = "podcast" ]; then
              MESSAGE="üéôÔ∏è Nuevo cap√≠tulo del podcast publicado: *${TITLE}*%0Aüîó ${URL}"
            else
              MESSAGE="üÜï Nuevo art√≠culo publicado en la web: *${TITLE}*%0Aüîó ${URL}"
            fi
            
            echo "üì§ Sending notification $((i+1))/$CONTENT_COUNT: $TITLE"
            
            # Send message with retry logic
            MAX_RETRIES=3
            RETRY_COUNT=0
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
                -d chat_id="$TELEGRAM_CHAT_ID" \
                -d text="$MESSAGE" \
                -d parse_mode="Markdown")
              
              OK=$(echo "$RESPONSE" | jq -r '.ok')
              if [ "$OK" = "true" ]; then
                echo "‚úÖ Successfully sent notification $((i+1))/$CONTENT_COUNT"
                break
              fi
              
              ERROR_CODE=$(echo "$RESPONSE" | jq -r '.error_code // empty')
              if [ "$ERROR_CODE" = "429" ]; then
                RETRY_AFTER=$(echo "$RESPONSE" | jq -r '.parameters.retry_after // 30')
                echo "‚è≥ Rate limit hit. Waiting $RETRY_AFTER seconds..."
                sleep $RETRY_AFTER
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                echo "‚ö†Ô∏è Attempt $RETRY_COUNT/$MAX_RETRIES failed. Response: $RESPONSE"
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  sleep 2
                fi
              fi
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "‚ùå Failed to send notification after $MAX_RETRIES attempts"
            fi
            
            # Small delay between messages
            sleep 1
          done
          
          echo "üéâ Notification process completed!"